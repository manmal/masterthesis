In this chapter, the computation of similarities between artists and construction of layouts based on those similarities will be presented.

\begin{itemize}
	\item \textbf {Matching of music entities from Different Sources} - Describes the methods used for merging music objects (artists, albums, titles) and their similarities, and how they deal with uncertainty regarding similarities.
	\item \textbf {Multidimensional Scaling Algorithm} - Gives details about the MDS algorithm employed for the layout of music collections.
	\item \textbf {Optimizations for Execution on Mobile Devices} - Elaborates on how aforementioned MDS algorithm can be optimized for the execution on devices with relatively low processing power.
	\item \textbf {Downsides of MDS in this Context} - Lists some downsides of the usage of MDS in the given context, as opposed to other layout methods.
\end{itemize}

\section{Matching of Music Entities from Different Sources}

In order to use similarity data from different information sources (here: web services), these data items have to be consolidated in a way that assures that they don't mix up - e.g., objects with the same name are assumed to depict the same artist (typos or naming variations should be amended).

The following approach has been chosen to perform the gathering and matching of different online sources of similarity data:

\begin{enumerate}
	\item A list of music files residing on the mobile device is compiled, and from there a list of locally available music entities (artists, albums, titles) is generated. This list of locally available music entities is not processed, meaning that spelling errors or duplicates are not amended.
	\item All locally available music entities (artists, albums, titles) are linked to corresponding entities in Last.fm's and Echonest's web APIs. This is done by issuing a search query for every locally available music entity to both APIs, and storing the query results on the device (using the query result's list's first item, assuming that it will in most cases resemble the desired music entity). The result is that each locally available music entity is augmented with metadata from both web APIs. Last.fm's representation of each music entity will from there on be used as authoritative metadata source, eliminating spelling errors in the locally available music entity.
	\item For all locally available artists, the Last.fm API is queried, returning a list of at most 100 similar artists for each available artist. This similarity ranking list contains a similarity measure in the range of [0..1] for every similar artist, where 1 means "'most similar or equivalent"' and 0 means "'not related at all"'.
	\item The similarity ranking lists retrieved in the last step are searched to find out whether they contain other locally available artists. This search currently is a case-insensitive equality comparison of artist names. If a locally available artist is found in a similarity ranking list, then the similarity value is stored without further processing, thus creating a similarity connection between one locally available artist and another locally available artist. If it is not foundin the similarity ranking list, then a statistical approximation is used (as described in the next paragraph).
\end{enumerate}

The results of these steps are: Music entity metadata that connects locally available entities with metadata from Last.fm and Echonest, and a number of similarity connections between locally available artists, retrieved from Last.fm. All the retrieved data resides in the device's memory or storage. In empirical tests, it has been found that as much as 90 percent or more of potential similarity connections cannot be established based on the web APIs' results. That means that up to 90 percent of artists in a music collection have no incoming or outgoing similarity link to another artist in the music collection. This is due to the fact that Last.fm will not output more than 100 entries of similar artists at this time, making it unlikely that artists are contained in each other's similarity ranking lists. It is not possible at this time to query Last.fm specifically for the similarity between an artist X and an artist Y, so the similarity between X and Y is only available when artist Y is in artist X's similar artists list, or vice versa. 
Omitting the definition of any default similarity value in such cases (leaving the similarity between examplary artists X and Y at zero or undefined) could generally be an option. However, the selected 2D-projection algorithm (multi-dimensional scaling algorithm using a spring model) produces undesirable results with this approach (placing artists without a similarity link at completely random positions, often far away from the other artists).
So, a meaningful default similarity for unknown similarities must be defined. A reasonable approach is to use a statistical approximation. An artist Y (who is not in the similarity ranking list of an artist X) must have a lower similarity to X than the least similar artist in the similarity ranking list of artist X. Since we lack any additional data, the expected similarity of artist X and artist Y then euals:\\
\emph{0.5 * [least similarity value in the similarity ranking list of artists of artist X]}.\\
This approximation is applied to all locally available artists which are not in 

\section{Multidimensional Scaling Algorithm}
\label{sec:mds-algorithm}

\subsection{Fitness of MDS for The Given Problem}

The subjective similarity of music, or artists in particular, can be expressed as attributes which are assigned by human beings (their opinions). Such attributes may be:

\begin{itemize}
	\item Rhythm
	\item Beats per minute
	\item Mood
	\item Popularity
	\item Genre
	\item Tuning
	\item ...
\end{itemize}

Whatever the assigned attributes are - by comparing attributes of music titles to those of other titles, a similarity measure can somehow be obtained. Every attribute then can be seen as another dimension, and every music title or artist is an object in a space of N dimensions, where N is the number of attributes assigned. Therefore, the problem of laying out music collections in two-dimensional layouts with respect to their subjective similarity can be reduced to a multidimensional scaling problem.
Since the previously mentioned web sources provide readymade similarity measures between artists, we can take a shortcut here, and remain oblivious of audio attributes such as rhythm or mood. It has not been publicized how Last.fm generates similarity information based on their users' behaviour, but it can be assumed that they use Collaborative Filtering algorithms ~\cite{Takacs:2007}, or market basket analysis ~\cite{Aggarwal99anew}. Due to the possibility of externalizing similarity data aggregation to a Web Service, a major part of spring model MDS work - the filtering and mapping of different attributes w.r.t. their impact on object similarity - is a solved problem. The similarities that are retrieved from Web Services can directly be used to calculate the length of the connecting springs.

\subsection{Concrete MDS Algorithm}

As mentioned before, the chosen MDS algorithm is based on a spring model. In the real world, steel rings interconnected with springs strive to form an equilibrium, where all forces enacted by the springs are balanced. In a perfect equilibrium, the position of every steel ring is a compromise of all forces acting on it, and the rings will not move anymore. The "'system stress"' is then zero. The real-world spring system will also produce non-perfect ending states because of energy loss in the system - at some point, the rings will not move anymore because the original kinetic energy has transformed into other forms of energy and is not available for movement of rigid springs.
In a digital emulation of this concept, objects are moved around by high-dimensional forces (springs) until, theoretically, an equilibrium has been reached. However, the balancing effect (swinging) produced by these forces cannot happen continuously as in the real word. Instead, the swinging spring effect is approximated by computing iterations, each representing a system state at a certain time. Since there is no loss of energy in the system (as observed in the real-world spring system) for every iteration, there are configurations in which the objects will be pushed around by the forces forever, never reaching a final static state. It is therefore common to limit the amount of iterations or regard the positions of objects as "'good enough"' when the system stress has fallen below a threshold. Since system stress grows proportionally to the number of objects (if stress among them stays the same), an optimal system stress threshold is non-trivial to calculate.
Research has produced both basic and more refined algorithms which approximate the behavior of a spring model. 
The most basic approach is mentioned in \cite{Chalmers:1996:LIT:244979.245035} (and then refined for faster computation) - 
it starts out by assigning coordinated in low dimensional space (2D or 3D is most likely) for each object (coordinates may be related to high dimensional coordinates, or may be randomized). Iterations are then performed on the low dimensional model, by performing these steps:

\begin{enumerate}
	\item For every object, calculate its supposed low dimensional distance (LDD) to every other object. The supposed LDD is determined by a custom function (e.g., the Euclidean distance). Here, this function takes a similarity value retrieved from web sources as a parameter.
	\subitem If the supposed LDD does not match the actual current LDD, calculate a force into a certain direction (vector), either attractive or repulsive (pulling to or pushing from each other), and save it for later application.
	\item Apply all previously saved forces onto the corresponding objects.
\end{enumerate}		

\section{Optimizations for Execution on Mobile Devices}

The most basic MDS algorithm described previously is computationally too expensive to perform with a reasonably large data set (up to 1000 objects) on a mobile device, at a complexity of $O(N^3)$ or $O(N^4)$ \cite{Chalmers:1996:LIT:244979.245035}. Chalmers therefore introduces a stochastic sampling method and the use of neighbor sets in \cite{Chalmers:1996:LIT:244979.245035}. Instead of performing force calculations for every object to every other object in each iteration, subsets of objects are picked and used randomly. Also, for every object a neighbor set is created which keeps objects of the lowest high-dimensional distances. It is reported in \cite{Chalmers:1996:LIT:244979.245035} that these optimizations reduce the algorithm's complexity to $O(N^2)$.

Further on, \cite{Morrison:2003:FMS} introduces another optimization: Initially, only a subset of all objects is selected and the aforementioned stochastic layout algorithm is performed on those. Then, the rest of the objects is added to the layout following an estimation of their best positions. Finally, the stochastic layout algorithm is performed again, for a limited number of iterations. Thus, the complexity of the algorithm is further reduced to $\mathcal O(N*\sqrt{N})$.

\subsection{Selected Algorithm in Detail}
\label{subsec:mds-selected-algorithm}

The optimized algorithm is composed of these steps (C1, C2, C3, C4 being predefined constants):

\begin{enumerate}
	\item Select a random subset of $\sqrt{N}$ objects (N = number of all objects)
	\item Perform a sampled MDS calculation on the initial layout, by performing C1 iterations of the following:
		\subitem For each object in the subset (called "'subject"') do:
			\subsubitem Generate a random subset of all objects containing C2 objects; concurrently, switch objects into subject's neighbor set if either the set has not reached its capacity, or if the object has a lower high-dimensional distance than the current most distant neighbor.
			\subsubitem For every object in either the random subset or the neighbor set, calculate its supposed low dimensional distance (LDD) to the subject. The supposed LDD is determined by a custom function (e.g., the Euclidean distance). Here, this function takes a similarity value retrieved from web sources as a parameter.
			\subsubitem If the supposed LDD does not match the actual current LDD, calculate a force for subject into a certain direction (vector), either attractive or repulsive, and save it for later application. (Note: Only the subject is moved)
		\subitem Apply all previously saved forces onto the corresponding subjects.
	\item For every object (called "'subject"') NOT in the initial subset do (subset Z containing all objects from the initial subset):
		\subitem Find the most similar (lowest high-dimensional distance) object in Z, and choose the best quadrant around it, to place the subject there. (There are four quadrants surrounding the most similar object, top-left, top-right, bottom-left, bottom-right.)
			\subsubitem Vectors are constructed from the most similar object to each quadrant's center, with a length corresponding to the similarity between the two objects.
			\subsubitem Positioning tests are performed by moving the subject to the end of each constructed vector, and calculating the stress between the most similar object and the temporarily moved subject. The vector of the quadrant which yields the lowest stress wins the test, and subject is assigned the resulting position, which is again the result of adding the vector to the most similar object's position.
		\subitem Improve on subject's new position by performing C3 iterations very similar to step 2., but only with the initial subset of objects.
		\subitem Add subject to Z.
	\item Perform a sampled MDS calculation like in step 2. with C4 iterations, but with all available objects instead of only the initial subset. The purpose is to move grossly mispositioned objects to a better position - very good results can be achieved with a low number of iterations (C4).
		
\end{enumerate}

\section{Downsides of MDS in This Context}

The advantages of MDS have been described sufficiently in this section. However, there are some downsides to this approach too, some of which are inherent to the problem at hand and which could not be alleviated by using another method.

If the internal structure of the transformed music entity set \textbf{is not expressible in a two-dimensional space without tradeoffs}, the spatial distances between entities will not always depict their similarity correctly. The larger the transformed set is, the more will the entities' 2D distances be different from their expected ("'should be"') distances. It can be viewed as a given that in most cases distances between some entities will not at all match their expected lengths.

The layout produced by the aforementioned MDS method \textbf{will never be the same for two different calculations}, since many parts of the algorithm involve randomness 
\footnote{The introduction of randomness in the layout creation algorithm has been necessary, as mentioned before, because it reduces its time complexity from $O(n^3)$ or even $O(n^4)$ to $\mathcal O(N*\sqrt{N})$. Without these optimizations, the algorithm would hardly be able to produce a layout in a mobile app in reasonable time.}.
While the addition of some entities is possible after the layout has been completed, a complete rerun of the algorithm will become necessary if similarities change. This is suboptimal for users because they have to reorient themselves after every major layout change.

The MDS method presented earlier in this chapter relies on definite high-dimensional vectors (from which similarity measures can be derived), which is not available here - in the context of computing similarity based on web sources, it is unlikely that a similarity measure can be found for every entity-entity relationship. Therefore, \textbf{estimations have to be used for unknown similarity relationships}, potentially polluting the calculation with incorrect values.

\section{Summary}

The matching of music entities from various sources has been described as a simple, straightforward process, and it was also mentioned how calculation of expected values can provide meaningful approximations for unknown similarities between artists. Subsequently, an introduction to multidimensional scaling and the simplest possible MDS algorithm was given. 

Optimizations which make execution of such a computation for a reasonable number of objects possible on a current mobile device have then been specified, namely the introduction of sampling and interpolation. Finally, downsides of the application of MDS for the generation of layouts were found - layouts would hardly ever look the same after two separate calculations, and estimations of unknown artist similarities may pollute the resulting layout.